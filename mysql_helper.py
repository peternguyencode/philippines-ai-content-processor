#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
MySQL Helper: X·ª≠ l√Ω import/export d·ªØ li·ªáu v·ªõi MySQL Database
Author: AI Assistant
Date: 2025-08-05
"""

import json
import logging
import re
from datetime import datetime
from typing import Any, Dict, List, Optional

import mysql.connector
from mysql.connector import Error

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class MySQLHelper:
    """L·ªõp x·ª≠ l√Ω k·∫øt n·ªëi v√† thao t√°c v·ªõi MySQL Database"""

    def __init__(
        self,
        host="localhost",
        port=3308,
        user="root",
        password="baivietwp_password",
        database="mydb",
    ):
        """
        Kh·ªüi t·∫°o k·∫øt n·ªëi MySQL

        Args:
            host: MySQL host
            port: MySQL port
            user: MySQL username
            password: MySQL password
            database: Database name
        """
        self.host = host
        self.port = port
        self.user = user
        self.password = password
        self.database = database
        self.connection = None

        try:
            self.connect()
            self.create_posts_table()
            logger.info("‚úÖ MySQL Helper kh·ªüi t·∫°o th√†nh c√¥ng!")

        except Exception as e:
            logger.error(f"‚ùå L·ªói kh·ªüi t·∫°o MySQL Helper: {str(e)}")
            raise

    def connect(self):
        """T·∫°o k·∫øt n·ªëi t·ªõi MySQL Database"""
        try:
            self.connection = mysql.connector.connect(
                host=self.host,
                port=self.port,
                user=self.user,
                password=self.password,
                database=self.database,
                charset="utf8mb4",
                collation="utf8mb4_unicode_ci",
            )

            if self.connection.is_connected():
                logger.info(
                    f"‚úÖ K·∫øt n·ªëi MySQL th√†nh c√¥ng: {self.host}:{self.port}/{self.database}"
                )

        except Error as e:
            logger.error(f"‚ùå L·ªói k·∫øt n·ªëi MySQL: {str(e)}")
            raise

    def create_posts_table(self):
        """T·∫°o b·∫£ng posts n·∫øu ch∆∞a t·ªìn t·∫°i"""
        create_table_query = """
        CREATE TABLE IF NOT EXISTS posts (
            id INT AUTO_INCREMENT PRIMARY KEY,
            source_title VARCHAR(255) DEFAULT NULL,
            status VARCHAR(50) DEFAULT 'pending',
            title TEXT NOT NULL,
            content LONGTEXT DEFAULT NULL,
            original_url TEXT DEFAULT NULL,
            image_url TEXT DEFAULT NULL,
            meta_title TEXT DEFAULT NULL,
            meta_description TEXT DEFAULT NULL,
            created_date DATETIME DEFAULT CURRENT_TIMESTAMP,
            keywords TEXT DEFAULT NULL,
            category VARCHAR(100) DEFAULT 'Casino',
            tags TEXT DEFAULT NULL,
            ai_model VARCHAR(50) DEFAULT NULL,
            notes TEXT DEFAULT NULL,
            processing_status VARCHAR(50) DEFAULT 'pending',
            
            UNIQUE KEY unique_title (title(255)),
            UNIQUE KEY unique_url (original_url(255)),
            INDEX idx_status (status),
            INDEX idx_category (category),
            INDEX idx_created_date (created_date)
        ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        """

        try:
            cursor = self.connection.cursor()
            cursor.execute(create_table_query)
            self.connection.commit()
            cursor.close()
            logger.info("‚úÖ B·∫£ng 'posts' ƒë√£ s·∫µn s√†ng")

        except Error as e:
            logger.error(f"‚ùå L·ªói t·∫°o b·∫£ng posts: {str(e)}")
            raise

    def clean_html_content(self, html_content: str) -> str:
        """L√†m s·∫°ch n·ªôi dung HTML"""
        if not html_content:
            return ""

        # Remove HTML tags
        clean_text = re.sub(r"<[^>]+>", "", html_content)
        # Remove extra spaces
        clean_text = re.sub(r"\s+", " ", clean_text).strip()
        # Remove HTML entities
        clean_text = re.sub(r"&#\d+;", "", clean_text)
        # Remove special characters that might cause issues
        clean_text = clean_text.replace("\x00", "").replace("\r", "").replace("\n", " ")

        return clean_text

    def extract_keywords_from_content(self, content: str, title: str) -> str:
        """Tr√≠ch xu·∫•t keywords t·ª´ content v√† title"""
        if not content and not title:
            return ""

        # Common casino keywords
        casino_keywords = [
            "casino",
            "bonus",
            "free",
            "sign up",
            "deposit",
            "philippines",
            "game",
            "slot",
            "win",
        ]

        text = f"{title} {content}".lower()
        found_keywords = [kw for kw in casino_keywords if kw in text]

        return ", ".join(found_keywords[:10])  # Limit to 10 keywords

    def insert_post(self, post_data: Dict[str, Any]) -> bool:
        """
        Insert m·ªôt post v√†o database

        Args:
            post_data: Dictionary ch·ª©a d·ªØ li·ªáu post

        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu th·∫•t b·∫°i
        """
        try:
            # Clean and prepare data
            title = post_data.get("title", "No title").strip()
            content = self.clean_html_content(post_data.get("content", ""))
            original_url = post_data.get("link", "")
            image_url = post_data.get("featured_image", "")

            # Create meta description from content
            meta_description = content[:160] + "..." if len(content) > 160 else content

            # Extract keywords
            keywords = self.extract_keywords_from_content(content, title)

            insert_query = """
            INSERT INTO posts (
                source_title, status, title, content, original_url, image_url,
                meta_title, meta_description, created_date, keywords, category,
                tags, ai_model, notes, processing_status
            ) VALUES (
                %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s
            )
            """

            values = (
                "bonus365casinoall",  # source_title
                "imported",  # status
                title,  # title
                content,  # content
                original_url,  # original_url
                image_url,  # image_url
                title,  # meta_title
                meta_description,  # meta_description
                datetime.now(),  # created_date
                keywords,  # keywords
                "Casino",  # category
                "bonus, casino, philippines, imported",  # tags
                "Manual Import",  # ai_model
                f"Imported from JSON at {datetime.now()}",  # notes
                "JSON-Imported",  # processing_status
            )

            cursor = self.connection.cursor()
            cursor.execute(insert_query, values)
            self.connection.commit()
            cursor.close()

            logger.info(f"‚úÖ Imported: {title[:50]}...")
            return True

        except mysql.connector.IntegrityError as e:
            if "Duplicate entry" in str(e):
                logger.warning(f"‚ö†Ô∏è Duplicate skipped: {title[:50]}...")
                return False
            else:
                logger.error(f"‚ùå Integrity error: {str(e)}")
                return False

        except Error as e:
            logger.error(f"‚ùå Error inserting post: {str(e)}")
            return False

    def import_from_json(self, json_file: str) -> Dict[str, int]:
        """
        Import to√†n b·ªô d·ªØ li·ªáu t·ª´ file JSON

        Args:
            json_file: ƒê∆∞·ªùng d·∫´n t·ªõi file JSON

        Returns:
            Dict ch·ª©a th·ªëng k√™ import
        """
        stats = {"total": 0, "success": 0, "duplicates": 0, "errors": 0}

        try:
            # Load JSON data
            with open(json_file, "r", encoding="utf-8") as f:
                posts = json.load(f)

            stats["total"] = len(posts)
            logger.info(f"üìä Loaded {stats['total']} posts from {json_file}")

            # Import each post
            for i, post in enumerate(posts, 1):
                try:
                    logger.info(
                        f"[{i}/{stats['total']}] Processing: {post.get('title', 'No title')[:50]}..."
                    )

                    if self.insert_post(post):
                        stats["success"] += 1
                    else:
                        stats["duplicates"] += 1

                except Exception as e:
                    logger.error(f"‚ùå Error processing post {i}: {str(e)}")
                    stats["errors"] += 1

            # Print final stats
            logger.info(f"\nüìà IMPORT COMPLETED:")
            logger.info(f"   Total processed: {stats['total']}")
            logger.info(f"   Successfully imported: {stats['success']}")
            logger.info(f"   Duplicates skipped: {stats['duplicates']}")
            logger.info(f"   Errors: {stats['errors']}")

        except FileNotFoundError:
            logger.error(f"‚ùå File not found: {json_file}")
            stats["errors"] = stats["total"] = 1

        except json.JSONDecodeError as e:
            logger.error(f"‚ùå Invalid JSON file: {str(e)}")
            stats["errors"] = stats["total"] = 1

        except Exception as e:
            logger.error(f"‚ùå Unexpected error: {str(e)}")
            stats["errors"] += 1

        return stats

    def export_to_json(self, output_file: str, limit: int = None) -> bool:
        """
        Export d·ªØ li·ªáu t·ª´ MySQL ra file JSON

        Args:
            output_file: ƒê∆∞·ªùng d·∫´n file JSON output
            limit: Gi·ªõi h·∫°n s·ªë b√†i export (None = t·∫•t c·∫£)

        Returns:
            bool: True n·∫øu th√†nh c√¥ng
        """
        try:
            query = "SELECT * FROM posts ORDER BY created_date DESC"
            if limit:
                query += f" LIMIT {limit}"

            cursor = self.connection.cursor(dictionary=True)
            cursor.execute(query)
            posts = cursor.fetchall()
            cursor.close()

            # Convert datetime objects to strings
            for post in posts:
                if post["created_date"]:
                    post["created_date"] = post["created_date"].isoformat()

            # Write to JSON file
            with open(output_file, "w", encoding="utf-8") as f:
                json.dump(posts, f, ensure_ascii=False, indent=2)

            logger.info(f"‚úÖ Exported {len(posts)} posts to {output_file}")
            return True

        except Exception as e:
            logger.error(f"‚ùå Export error: {str(e)}")
            return False

    def get_posts_count(self) -> Dict[str, int]:
        """L·∫•y th·ªëng k√™ s·ªë l∆∞·ª£ng posts theo status"""
        try:
            cursor = self.connection.cursor()

            # Total posts
            cursor.execute("SELECT COUNT(*) as total FROM posts")
            total = cursor.fetchone()[0]

            # Posts by status
            cursor.execute(
                "SELECT status, COUNT(*) as count FROM posts GROUP BY status"
            )
            status_counts = dict(cursor.fetchall())

            cursor.close()

            return {"total": total, "by_status": status_counts}

        except Exception as e:
            logger.error(f"‚ùå Error getting posts count: {str(e)}")
            return {"total": 0, "by_status": {}}

    def check_connection(self) -> bool:
        """Ki·ªÉm tra k·∫øt n·ªëi MySQL"""
        try:
            if self.connection and self.connection.is_connected():
                cursor = self.connection.cursor()
                cursor.execute("SELECT 1")
                cursor.fetchone()
                cursor.close()
                return True
            else:
                return False
        except:
            return False

    def close(self):
        """ƒê√≥ng k·∫øt n·ªëi MySQL"""
        try:
            if self.connection and self.connection.is_connected():
                self.connection.close()
                logger.info("‚úÖ MySQL connection closed")
        except Exception as e:
            logger.error(f"‚ùå Error closing connection: {str(e)}")


# Main function for testing
if __name__ == "__main__":
    print("üî• MYSQL HELPER TEST üî•")
    print("=" * 50)

    try:
        # Initialize MySQL Helper
        mysql_helper = MySQLHelper()

        # Test connection
        if mysql_helper.check_connection():
            print("‚úÖ MySQL connection is healthy")

            # Get current posts count
            stats = mysql_helper.get_posts_count()
            print(f"üìä Current posts in database: {stats['total']}")
            print(f"üìä By status: {stats['by_status']}")

            # Test import (uncomment to run)
            # print("\nüöÄ Starting JSON import...")
            # import_stats = mysql_helper.import_from_json('bonus365casinoall_posts.json')
            # print(f"üéâ Import completed: {import_stats}")

        else:
            print("‚ùå MySQL connection failed")

    except Exception as e:
        print(f"‚ùå Error: {str(e)}")

    finally:
        if "mysql_helper" in locals():
            mysql_helper.close()
